# Code Explanation
As seen in the image, we are dealing with a bar of length L, whose temperature, denoted u, is a function of x, the position along the bar, and t, the time. u=u(x,t). The ends of the bar are kept constant at temperature 0, u(0,t)=u(L,t)=0 for t>=0. These are called boundary conditions. Furthermore, u(x,0)=f(x), meaning the initial temperature is a function only of x, the position. This is called the initial condition. We can make f(x) any function we want, or it can be random. Notice that f(0)=f(L)=0 given the boundary conditions. Numerically, we cannot solve for u(x,t) exactly. What we can do, however, is solve for u(x,t) given a mesh. A mesh is a coordinate of position and time values, where position can be denoted by i and time by j. There is already a constraint on i, since the bar is of finite length. We need a constraint on time, so that we can measure the temperature on each point along the bar at this given time. As in all numerical method solutions, we need a step size. Assume we have N+1 points along the bar, equally spaced, with the 1st point corresponding to x=0 and the N+1th point corresponding to x=L. It is clear that there are N subintervals across the bar. Our spatial step size, deltax, becomes equal to L/N. To make the process more clear, we can denote x_i= i(deltax) for i=0,...N. This helps in the stencil diagram provided in the image, where u_i,j can denote the value at x_i, t_j. However, in the code, we can simplify. We are given an array, T_initial, of the initial temperature distribution given by some f(x) (possibly random, we are using the most general definition of a function). The length of this array is what we use to generate x, which is the array of initial space points along the bar. np.linspace(0,L,nx), where nx=len(T_initial), generates equally spaced points along the bar, including 0 and L. Our step size, dx, is also dependent on nx. The calculation is the same as we described above, nx is the number of points, nx-1 becomes the number of intervals, so dx= L/(nx-1), simple. We have more control over dt. We are given t_final as our final time, so dividing it by some whole number that will represent time intervals can get us our needed dt. Finally, k is the themeral diffusivity constant, or a proportionality constant (k) in the PDE. Now we have enough context to discuss the centered finite difference method. The derivation is provided in the image. We get a new parameter, alpha, which is k(dt)/(dx)^2. The names of the variables change in our code, but the math remains the same. The image provided has the derivation for why alpha < 1/2. Notice on the left hand side, we have u(x,t+dt), on the right hand side, we have three terms, u(x+dx,t), u(x,t), u(x-dx,t). This helps in our geometric understanding of the process. we start at t=0, so effectively, for the interior points (x_i | i=1,...,N-1), u_i,0= f(x_i), which is given in T_initial. Then using the values to the left and right, we can compute the values for u_i,1. Notice that at i=1,N-1, we have the value 0 on the left and right respectively for all dt. This means that for t= j(dt), j>=1, we will always compute u_1,j using only u_1,j-1 and u_2,j-1
and we will always compute u_N-1,j using u_N-1,j-1 and u_N-2,j-1. This process is described visually using the stencil diagram. The code reflects this same process. Since the exterior nodes, i=0,N have u_i,j=0 for all j, there is no point in updating these values. The code structure is simple, our goal is to get the final time distribution, denoted T. We also want to keep track of the times and the temperature distributions at each time. let the array of temperature distributions be called T_snapshots. If we want 10 snapshots, we do snapshot_interval= t_final/10,next_snapshot = snapshot_interval. We have a time step size, dt. n_steps= int(t_final/dt), this is the number of steps needed to reach t_final. For each step, we need to update the temperature distribution. This requires a simple nested for-loop structure. for each time step, we need to update the interior nodes, then reassign the temp. array to be used on the next time step. This is an iterative process. At the end, we also need to update t, using t += dt. Since t is initialized at 0, (t=0), and times=[0], if t>=next_snapshot, append t to times, and append the temperature distribution at this snapshot to T_snapshots. Note that the only requirement here is for dt<=snapshot_interval. Otherwise, we will not be able to get all the snapshots we need. The updating of the temperature array on each iteration also requires a for loop, but the logic is simple. For each time step, iterate from i=1 to i=N-1, and then use the same formula given in the image to update T[i]. If we have Direchlet conditions, keep the endpoints the same. 
